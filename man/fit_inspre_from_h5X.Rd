% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/inspre_h5.R
\name{fit_inspre_from_h5X}
\alias{fit_inspre_from_h5X}
\title{Fits inverse sparse regression model.}
\usage{
fit_inspre_from_h5X(
  X,
  X_control,
  X_ids,
  X_vars,
  targets,
  weighted = TRUE,
  max_med_ratio = NULL,
  filter = TRUE,
  rho = 100,
  lambda = NULL,
  lambda_min_ratio = 0.01,
  nlambda = 20,
  alpha = 0,
  gamma = NULL,
  its = 100,
  delta_target = 1e-04,
  verbose = 2,
  cv_folds = 0,
  mu = 10,
  tau = 1.5,
  solve_its = 10,
  ncores = 1,
  min_nz = 0.01,
  warm_start = FALSE,
  constraint = "UV",
  DAG = FALSE,
  save_cv_graphs = FALSE
)
}
\arguments{
\item{X}{H5D. Example: `X=hfile[['X']]` where hfile is an hdf5r object
containing a data matrix stored under label 'X'.}

\item{X_control}{Matrix. features by control observations. Usually
pulled from X but stored in memory so you don't have to pull the
same control observations off of disk for every instrument.}

\item{X_ids}{Sequence of strings with length equal to number of columns in
X. Entries correspond to the instrument applied to that entry.}

\item{X_vars}{Sequence of strings with length equal to the number of rows
in X. Name of the feature measured in that row.}

\item{targets}{List. Entries correspond to variables in X (`X_vars`), names
correspond to the instrument targeting that variable (`X_ids`). These targets
will be used to calculate causal effect sizes.}

\item{max_med_ratio}{Float or NULL. Passed through to `make_weights`, NULL
for no weights.}

\item{filter}{Bool. True to filter the produced TCE matrix with `fitler_tce`.}

\item{rho}{Float. Initial learning rate for ADMM.}

\item{lambda}{Float, sequence of floats of NULL. L1 regularization strength
on inverse of X. If NULL, a logarithmicly spaced set of values between
the maximum absolute off diagonal element of X and lambda_min_ratio
times this value will be used.}

\item{lambda_min_ratio}{Float, ratio of maximum lambda to minimum lambda.}

\item{nlambda}{Integer. Number of lambda values to try.}

\item{alpha}{Float between 0 and 1 or NULL. If > 0, the model will be fit
once with gamma = 0 to find L0, then all subsequent fits will use
gamma = alpha * L0 / D. Set to NULL to provide gamma directly.}

\item{gamma}{Float or sequence of nlambda floats or NULL. Determinant
regularization strength to use (for each lambda value). It is recommended
to set alpha rather than setting this directly.}

\item{its}{Integer. Maximum number of iterations.}

\item{delta_target}{Float. Target change in solution.}

\item{verbose}{0, 1 or 2. 2 to print convergence progress for each lambda,
1 to print convergence result for each lambda, 0 for no output.}

\item{cv_folds}{Integer. Number of cross-validation folds to perform.}

\item{mu}{rho modification parameter for ADMM. Rho will be
increased/decreased when the dual constrant and primal constraint are off
by a factor of > mu.}

\item{tau}{rho modification parameter for ADMM. When called for, rho will be
increased/decreased by the factor tau.}

\item{solve_its}{Integer, number of iterations of bicgstab/lasso to run
for each U and V update.}

\item{ncores}{Integer, number of cores to use.}

\item{warm_start}{Logical. Whether to use previous lambda value result as
starting point for next fit.}

\item{constraint}{One of "UV" or "VU". Constraint to use.}

\item{DAG}{Bool. True to resitrict solutions to approximate DAGs.}

\item{vars_to_use}{Sequence of strings. Entries in X_vars to keep. Default
NULL to keep all.}

\item{obs_to_use}{Sequence of bools. Indicator of columns of X to use in calculations.
Useful for cross validation.}

\item{train_prop}{Float between 0 and 1. Proportion of data to use for
training in cross-validation. NOT USED.}
}
\description{
See also inspre::inspre() for more details.
}
